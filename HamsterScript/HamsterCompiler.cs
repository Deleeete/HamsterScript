using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using System.IO;
using System.Diagnostics;
using Gleee.Consoleee;

namespace Hamster
{
    static class HamsterCompiler
    {
        private static string GetTemplate()
        {
            string template = @$"
namespace {ScriptNamespace}
{{
    static class {ScriptClass}
    {{
        public static void Main(string[] args)
        {{
            //Console.Clear();
            Console.WriteLine(""[Hamster]'#SCRIPT_FILE_NAME#': \n\n"");
            try
            {{
                #SCRIPT#
            }}
            catch (Exception e3X3c5E5p0T3i3O6n)
            {{
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($""Script exception: {{e3X3c5E5p0T3i3O6n.Message}}\nStack trace: \n{{e3X3c5E5p0T3i3O6n.StackTrace}}"");
                Console.ResetColor();
            }}
        }}
    }}
}}";
            return template.Replace("\r\n", "\n");
        }
        private static readonly Stopwatch sw = new();
        private const string claim = "This file is generated by hamster compiler";
        public static string ScriptNamespace { get; set; } = "Hamster.Script";
        public static string ScriptClass { get; set; } = "Script";
        public static List<string> DefaultNamespaces { get; } = new List<string> 
        { 
            "System", 
            "System.Collections.Generic", 
            "System.Linq",
            "System.Text.RegularExpressions",
            "Hamster"
        };
        public static string ScriptMacro { get; set; } = "#SCRIPT#";
        public static string ScriptFileNameMacro { get; set; } = "#SCRIPT_FILE_NAME#";
        public static Func<int, string> StringMacro { get; set; } = (x) => $"#REMOVED_STR_{x}#";
        static readonly string assembly_home = Path.GetDirectoryName(typeof(object).Assembly.Location);
        //static char[] splitors = new char[] { '\n', ';' };

        static readonly CSharpCompilationOptions options = new (
            outputKind: OutputKind.DynamicallyLinkedLibrary,
            optimizationLevel: OptimizationLevel.Debug,
            metadataImportOptions: MetadataImportOptions.All);

        /// <summary>
        /// Translate hamster script to compilable C# code
        /// </summary>
        /// <param name="code"></param>
        /// <returns></returns>
        public static (string, List<string>) TranslateToCSharp(string script_file_name, string code)
        {
            sw.Restart();
            string csharp_code = "Failed to translate.";
            code = code.Replace("\r", "").Replace(";", "\n");
            string[] lines = code.Split("\n");
            List<string> strs = new();
            List<string> namespaces = new();
            List<string> translated_lines = new();
            Program.console.WriteOperationLn("Translating hamster script to C# code", () => 
            {
                for (int ip = 0; ip < lines.Length; ip++)
                {
                    string line = lines[ip];
                    //Extract strings first to make it easier to process later
                    strs.AddRange(RemoveStrings(line, out string line_string_processed));
                    //Generate using expression
                    namespaces.AddRange(ExtractNamespace(line_string_processed, out string line_using_processed));
                    //Process macro
                    string line_macro_processed = ReplaceMacro(line_using_processed, Pattern.RunCmdMacro, "HamsterCoreLib.RunCommand($\"%\")");       //所有接收字符的宏默认开内插
                    line_macro_processed = ReplaceMacro(line_macro_processed, Pattern.OutMacro, "HamsterCoreLib.GetCommandOutput($\"%\")");
                    line_macro_processed = ReplaceMacro(line_macro_processed, Pattern.EchoMacro, "Console.WriteLine($\"%\")");
                    //recover strings
                    for (int i = 0; i < strs.Count; i++)
                    {
                        line_macro_processed = line_macro_processed.Replace(StringMacro(i), strs[i]);
                    }
                    translated_lines.Add(line_macro_processed);
                }
            });
            namespaces.AddRange(DefaultNamespaces);
            string using_block = BuildUsingBlock(namespaces);
            string translated_code = string.Join(';', translated_lines) + ";";
            string script_block = GetTemplate().Replace(ScriptFileNameMacro, script_file_name).Replace(ScriptMacro, translated_code);
            csharp_code = $"//{claim}\n{using_block}\n{script_block}\n";
            sw.Stop();
            Program.console.WriteLn($"Translated to C# in {sw.ElapsedMilliseconds} ms.", ConsoleErrorLevel.Info);
            return (csharp_code, namespaces);
        }
        /// <summary>
        /// Compile C# code
        /// </summary>
        /// <param name="code"></param>
        public static Assembly CompileCSharp(string code, List<string> namespaces)
        {
            using var ms = new MemoryStream();
            sw.Restart();
            Assembly asm = null;
            Program.console.WriteOperationLn("Compiling generated C# code", () => 
            {
                SyntaxTree[] syntax_trees = new SyntaxTree[] { CSharpSyntaxTree.ParseText(code) };
                options.WithUsings(DefaultNamespaces);
                List<MetadataReference> references = new()
                {
                    MetadataReference.CreateFromFile(typeof(object).Assembly.Location),                   //引入System.Private.CoreLib.dll
                    MetadataReference.CreateFromFile(typeof(Console).Assembly.Location),                 //引入System.Console.dll
                    MetadataReference.CreateFromFile(Path.Combine(assembly_home, "System.Runtime.dll")),//引入System.Runtime.dll 这个似乎没法通过反射拿到路径
                    MetadataReference.CreateFromFile(typeof(HamsterCoreLib).Assembly.Location),
                };
                Console.WriteLine();
                Program.console.WriteLn($"Assembly home: {assembly_home}", ConsoleErrorLevel.Info);
                foreach (string ns in namespaces)
                {
                    string test_path = Path.Combine(assembly_home, $"{ns}.dll");
                    if (File.Exists(test_path))
                    {
                        references.Add(MetadataReference.CreateFromFile(test_path));
                        Program.console.WriteLn($"Automatically added reference to {ns}.dll", ConsoleErrorLevel.Info);
                        continue;
                    }
                }
                compile:
                CSharpCompilation compilation = CSharpCompilation.Create("Script", syntax_trees, references, options);
                EmitResult result = compilation.Emit(ms);

                if (!result.Success)
                {
                    //handle exceptions
                    var failures = result.Diagnostics.Where(diagnostic => diagnostic.IsWarningAsError || diagnostic.Severity == DiagnosticSeverity.Error);
                    string re = "Compilation failed: \n";
                    bool has_resolvable_error = false;
                    foreach (Diagnostic diagnostic in failures)
                    {
                        re += $"At [{diagnostic.Location.GetLineSpan().StartLinePosition}]: {diagnostic.GetMessage()}({diagnostic.Id})\n";
                        if (diagnostic.Id == "CS0246")
                        {
                            has_resolvable_error = true;
                            string type_name = GetMissingTypeName(code, diagnostic);
                            Program.console.WriteLn($"{diagnostic.Id} detected. Trying to automatically resolve assembly reference for '{type_name}'...", ConsoleErrorLevel.Warning);
                            string full_type_name = "";
                            foreach (string ns in namespaces)
                            {
                                string test = $"{ns}.{type_name}.dll";
                                Program.console.WriteLn($"Testing {test} in {assembly_home}...", ConsoleErrorLevel.Info);
                                if (File.Exists(Path.Combine(assembly_home, test)))
                                {
                                    full_type_name = $"{ns}.{type_name}";
                                    break;
                                }
                            }
                            if (full_type_name == "")
                            {
                                Program.console.WriteLn($"Cannot automatically resolve assembly reference for '{type_name}'.", ConsoleErrorLevel.Error);
                                has_resolvable_error = false;
                            }
                            else
                            {
                                Program.console.WriteLn($"Resolved '{type_name}' -> '{full_type_name}'. Adding to references... ", ConsoleErrorLevel.Info);
                                references.Add(MetadataReference.CreateFromFile(Path.Combine(assembly_home, $"{full_type_name}.dll")));
                            }
                        }
                    }
                    if (has_resolvable_error)
                    {
                        Program.console.WriteLn($"Auto-fix is possible. Retrying...", ConsoleErrorLevel.Info);
                        goto compile;
                    }
                    throw new Exception(re);
                }
                else
                    asm = Assembly.Load(ms.ToArray());
            });
            sw.Stop();
            Program.console.WriteLn($"Compile to assembly in {sw.ElapsedMilliseconds} ms.", ConsoleErrorLevel.Info);
            return asm;
        }
        /// <summary>
        /// Execute compiled C# assembly
        /// </summary>
        /// <param name="asm">compiled C# assembly</param>
        /// <param name="args">string arguments</param>
        public static void ExecuteCSharp(Assembly asm, string[] args)
        {
            Type type = asm.GetType($"{ScriptNamespace}.{ScriptClass}");
            MethodInfo method = type.GetMethod("Main");
            method.Invoke(null, new object[] { args });
        }
        /// <summary>
        /// Compiled string to C# assembly and execute
        /// </summary>
        /// <param name="code">code string</param>
        /// <param name="args">string arguments</param>
        public static void ExecuteCSharp(string code, List<string> namespaces, string[] args) => ExecuteCSharp(CompileCSharp(code, namespaces), args);
        /// <summary>
        /// Translate, compile and execute hamster script
        /// </summary>
        /// <param name="code">hamster script</param>
        /// <param name="args">string arguments</param>
        public static void ExecuteHamster(string script_file_name, string code, string[] args)
        {
            var tuple = TranslateToCSharp(script_file_name, code);
            ExecuteCSharp(CompileCSharp(tuple.Item1, tuple.Item2), args);
        } 

        //String manipulation
        private static string[] RemoveStrings(string code, out string str_free_code)
        {
            var matches = Pattern.string_pat.Matches(code).ToArray();
            string[] strs = new string[matches.Length];
            for (int i = 0; i < matches.Length; i++)
            {
                strs[i] = matches[i].Groups[1].Value;
                code = code.Replace(strs[i], StringMacro(i));
            }
            str_free_code = code;
            return strs;
        } 
        private static List<string> ExtractNamespace(string code, out string using_free_code)
        {
            List<string> namespaces = new();
            var matches = Pattern.using_pat.Matches(code);
            foreach (Match match in matches)
            {
                namespaces.Add(match.Groups[1].Value);
            }
            using_free_code = Pattern.using_pat.Replace(code, "");
            return namespaces;
        }
        private static string BuildUsingBlock(List<string> namespaces)
        {
            string using_block = "";
            foreach (var namespace_str in namespaces)
            {
                using_block += $"using {namespace_str};\n";
            }
            return using_block;
        }
        //Macro
        private static string ReplaceMacro(string code, Regex pat, string template)
        {
            string[] components = template.Split('%');
            if (components.Length != 2)
                throw new Exception("Too many seperator in template string. Expecting only one. ");
            foreach (Match match in pat.Matches(code))
            {
                string value = match.Groups[1].Value.Replace("\\", "\\\\");   //escape strings in macro to properly compile
                code = code.Replace(match.Value, $"{components[0]}{value}{components[1]}");
            }
            return code;
        }
        //Helpers
        private static string GetMissingTypeName(string code, Diagnostic diagnostic)
        {
            return code.Substring(diagnostic.Location.SourceSpan.Start, diagnostic.Location.SourceSpan.Length);
        }
    }
    static class Pattern
    {
        public static Regex using_pat = new(@"using ([a-zA-Z_\.]+);");
        public static Regex string_pat = new("\"(.+?)\"");
        #region Macro
        public static Regex RunCmdMacro { get; } = new Regex(@"#\s*run\s*:\s*([^\n^#]+#?)");
        public static Regex OutMacro { get; } = new Regex(@"#\s*out\s*:\s*([^\n^#]+)#?");
        public static Regex EchoMacro { get; } = new Regex(@"#\s*echo\s*:\s*([^\n^#]+)#?");
        #endregion
    }
}